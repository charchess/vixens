#!/usr/bin/env just --justfile
# workflow.just - Backend bd (Beads) + Frontends Serena/Archon

set shell := ["bash", "-uc"]

JUST := "just -f WORKFLOW.just"

# ============================================
# COMMANDE PRINCIPALE : Reprendre la bonne t√¢che
# ============================================
default:
    @{{JUST}} resume

resume:
    #!/usr/bin/env python3
    import subprocess, json, sys
    
    result = subprocess.run(
        ["bd", "list", "--status", "in_progress", "--assignee", "coding-agent", "--json"],
        capture_output=True, text=True
    )
    
    if result.returncode != 0:
        print("‚ùå Erreur bd:", result.stderr)
        sys.exit(1)
    
    tasks = json.loads(result.stdout)
    
    if tasks:
        t = tasks[0]
        print(f"üî• RESUME: {t['id']} | {t['title']}")
        print(f"   Commande: {{JUST}} work {t['id']}")
    else:
        print("üìã AUCUNE T√ÇCHE EN COURS. TODO:")
        subprocess.run(["bd", "list", "--status", "open", "--json", "--limit", "10"])

# ============================================
# TRAVAILLER SUR UNE T√ÇCHE (Orchestration)
# ============================================
work task_id:
    bd update {{task_id}} --status in_progress --assignee coding-agent
    @echo "=== Phase 1: Pr√©requis ==="
    {{JUST}} _check-prereqs {{task_id}}
    
    @echo "=== Phase 2: Doc Application ==="
    {{JUST}} _load-doc {{task_id}}
    
    @echo "=== Phase 3: Ex√©cution (Gemini) ==="
    @echo "   üí° Gemini: analyse et propose des changements"
    @echo "   üí° Utiliser: @serena pour le code, @archon pour le RAG"
    
    @echo "=== Phase 4: Validation FORC√âE ==="
    {{JUST}} _validate {{task_id}}

# ============================================
# SOUS-√âTAPES (Priv√©es)
# ============================================

_check-prereqs task_id:
    #!/usr/bin/env python3
    import subprocess, json, re, sys
    
    try:
        task_data = subprocess.run(
            ["bd", "show", "{{task_id}}", "--json"], 
            capture_output=True, text=True, check=True
        ).stdout
        
        tasks = json.loads(task_data)
        if not tasks:
            print("   ‚ö†Ô∏è  T√¢che non trouv√©e")
            sys.exit(1)
        task = tasks[0]
        title = task.get("title", "")
        
        if "PVC" in title and "RWO" in title:
            print("   ‚ö†Ô∏è  ALERTE: PVC RWO d√©tect√© ‚Üí strategy: Recreate n√©cessaire")
            subprocess.run([
                "bd", "update", "{{task_id}}", 
                "--notes", "AUTO: PVC RWO n√©cessite strategy: Recreate"
            ])
    except Exception as e:
        print(f"   ‚ö†Ô∏è  Erreur lecture t√¢che: {e}")
        sys.exit(1)

_load-doc task_id:
    #!/usr/bin/env python3
    import subprocess, json, re, sys
    
    try:
        task_data = subprocess.run(
            ["bd", "show", "{{task_id}}", "--json"], 
            capture_output=True, text=True, check=True
        ).stdout
        
        tasks = json.loads(task_data)
        if not tasks:
            print("   ‚ö†Ô∏è  T√¢che non trouv√©e")
            sys.exit(0)
        task = tasks[0]
        title = task.get("title", "")
        match = re.search(r'\(([^)]+)\)', title)
        
        if match:
            app_name = match.group(1)
            print(f"   üìñ Doc √† consulter: docs/applications/{app_name}.md")
            print(f"   üí° Commande Gemini: @serena get_file_content docs/applications/{app_name}.md")
        else:
            print("   ‚ÑπÔ∏è  Pas d'app d√©tect√©e dans le titre")
    except:
        print("   ‚ö†Ô∏è  Erreur lecture t√¢che")

_validate task_id:
    #!/usr/bin/env python3
    import subprocess, json, re, sys

    try:
        task_data = subprocess.run(
            ["bd", "show", "{{task_id}}", "--json"],
            capture_output=True, text=True, check=True
        ).stdout

        tasks = json.loads(task_data)
        if not tasks:
            print("   ‚ö†Ô∏è  T√¢che non trouv√©e")
            sys.exit(1)
        task = tasks[0]
        title = task.get("title", "")
        match = re.search(r'\(([^)]+)\)', title)

        if not match:
            print("   ‚ùå ABORT: Pas d'application √† valider")
            sys.exit(1)

        app_name = match.group(1)
        print(f"   üé≠ VALIDATION DEV: {app_name}")

        result = subprocess.run([
            "python3", "scripts/validate.py", app_name, "dev"
        ], capture_output=True, text=True)

        if result.returncode != 0:
            print(f"   ‚ùå VALIDATION √âCHOU√âE")
            subprocess.run([
                "bd", "update", "{{task_id}}",
                "--notes", f"VALIDATION FAIL: {result.stderr}"
            ])
            sys.exit(1)

        print("   ‚úÖ VALIDATION DEV OK")

        # Documentation reminder
        print("\n   ‚≠ê RAPPEL DOCUMENTATION (OBLIGATOIRE) ‚≠ê")
        print(f"   [ ] 1. Mettre √† jour docs/applications/<category>/{app_name}.md")
        print("   [ ] 2. Mettre √† jour docs/STATUS.md")
        print("   [ ] 3. Committer les changements de documentation")
        print("   [ ] 4. V√©rifier que tout est pouss√© (git push)")
        print()

        subprocess.run([
            "bd", "update", "{{task_id}}",
            "--status", "closed", "--assignee", "user"
        ])
    except Exception as e:
        print(f"   ‚ùå Erreur validation: {e}")
        sys.exit(1)

# ============================================
# UTILITAIRES
# ============================================

burst title:
    bd create "{{title}}" --status open --assignee coding-agent --label burst
    @echo "‚úÖ Id√©e enregistr√©e dans Beads"

lint:
    #!/usr/bin/env bash
    set -euo pipefail
    echo "üîç Validation YAML avec yamllint..."
    if yamllint -c yamllint-config.yml apps/**/*.yaml argocd/**/*.yaml; then
        echo "‚úÖ Validation YAML r√©ussie"
        exit 0
    else
        echo "‚ùå Validation YAML √©chou√©e"
        echo ""
        echo "‚ö†Ô∏è  Ces erreurs bloqueront le push dans GitHub Actions"
        echo "üí° Corrigez les erreurs avant de faire git push"
        exit 1
    fi
